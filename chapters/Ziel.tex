\section{Ziel} \label{sec:Ziel}

Laut Marcus Adrian et al.  gibt es 5 Dimensionen die man beachten muss, wenn es um software visualierung geht: 
\begin{quote}    
    • Tasks - why is the visualization needed?
    • Audience - who will use the visualization?
    • Target - what is the data source to represent?
    • Representation - how to represent it?
    • Medium - where to represent the visualization? \cite[2]{3dsoftwareMarcus}
\end{quote}

Wir beantworten diese Fragen, um das Ziel dieser Arbeit zu begründen.
\textbf{Warum ist die Visualisierung von Codequalitätsmetriken wichtig?}
Die Visualisierung von Codequalitätsmetriken ist wichtig, um die Qualität von Softwareprojekten zu bewerten und zu verstehen, aber auch um einen schnellen Überblick über die Codebasis zu geben und einen Einstieg in vertiefende Codeanalysen zu ermöglichen. Eine effektive Visualisierung kann helfen, schnell Hotspots im Code zu identifizieren, die möglicherweise verbessert werden müssen, und somit die Wartbarkeit und Qualität des Codes zu erhöhen. Außerdem soll die Visualisierung ermöglichen verschiedene Metriken in verbindung zu setzen, um so eine höhere Aussagekraft über den Code, den die einzelne betrachtung jeder Metrik nicht bieten kann.
Der wichtigste Punkt ist, das subjektive \textit{Greifbar} machend der CodeQualität.

\textbf{Wer wird die Visualisierung nutzen?}
Die Visualisierung ist vorallem an Personen gerichtet, die sich nicht mit der Codebasis auskennen. Das können Entscheidungsträger sein, die keine ahung von software entwicklung haben, das können aber auch entwickler sein, die sich neu in ein Projekt einarbeiten müssen, um die qualität einer software zu erhöhen.

\textbf{Was ist die Datenquelle?}
Die Datenquelle sind hierarschiche Codequalitätsmetriken, die aus dem Quellcode eines Softwareprojekts extrahiert werden. 
Dabei wird jeder Knoten in dieser Hierarchie als "Node" bezeichnet.
Jede Node hat folgendes Schema:
```json
"node": {
    "name": string,
    "children": List[Node] | "value": number,
}
```


\textbf{Wo soll die Visualisierung dargestellt werden?}
Die Visualisierung soll digital auf herkömmlichen Bildschirmen dargestellt werden. Speziell wird in dieser Arbeit beispielhaft eine darstellung in einem Webbrowser angestrebt und die Algorithmen in Typescript implementiert. Natürlich können aber alle Ergebnisse auch in anderen Programmiersprachen und Umgebungen umgesetzt werden.


\textbf{Wie soll die Visualisierung dargestellt werden?}
Im GRunde soll eine Visualierung in Anlehnung an den in Abschnitt \ref{sec:CodeCity} beschriebenen Stadt-Metapher ansatz verfolgt werden. - Speziell soll es in dieser Arbeit um das Layout der Knoten gehen, aber im hinterkopf soll die stadtmetapher bleiben und immer als grundlage für die bewrtung des 2d layouts dienen. 
Wie in der CodeCity arbeit beschrieben, soll es möglich sein Metriken in form von Fläche, Höhe und farbe (ob jetzt nur farbe oder durchsichtigkeit wie bei dem codecity paper oder sogar textur von knoten - wird hier ignoriert). Das heißt also, dass das 2D layout in gewisser weise eingeschtränkt wird, zB. wenn Farbe als visulaisrung von struktur verwendet werden soll oder wie in \cite{bruls2000squarified} schattierung.

Speziell soll die Visualisierung am Ende optimiert auf folgende Aspekte sein, die sich aus den im Abschnitt \ref{sec:Grundlagen} beschriebenen Grundlegenden Aspekten von Softwarevisualierung, leicht angepasst and das Problem dieser Arbeit, ableiten lassen: 

\begin{itemize}
    \item \textbf{Informationsgehalt und Effiziente Nutzung des Platzes:} Die Visualisierung sollte so viele Informationen wie möglich auf so wenig Platz wie möglich darstellen.
    \item \textbf{Niedrige visuelle Komplexität und Verständlichkeit:} Als Gegenspieler zum Informationsgehalt steht die visuelle Komplexität. Die Visualisierung sollte so einfach und verständlich wie möglich gehalten werden, um den Betrachter nicht zu überfordern.
    \item \textbf{Skalierbarkeit:} Die Visualisierung sollte auch bei großen Software-Systemen noch gut lesbar sein. Dies ist besonders wichtig, da wir hier über große Software-Systeme sprechen.
    \item \textbf{Korrelation mit dem Code:} Die Visualisierung sollte eine gute Korrelation mit dem Code haben. Wenn man die Visualierung sieht, soll man diese auch mit dem Code in Verbindung bringen können. Es sollte also möglich sein, die Visualisierung mit dem Code zu verknüpfen und so ein besseres Verständnis für die Software zu bekommen.
    \item \textbf{Zweitrangig ist Stabilität gegenüber Änderungen:} Die Visualisierung sollte stabil gegenüber Änderungen in der Software sein, damit der Qualitätszustand der Software einfacher über die Zeit verfolgt werden kann.
\end{itemize}

\subsection{Kriterien} \label{sec:ZielKriterien}
Um disese fünf Aspekte zu erreichen, definieren wir sechs Kriterien für das 2D layout, die diese Aspekte messbar machen. Diese Kriterien sollen helfen, die Qualität der Visualisierung zu bewerten und zu vergleichen. Die Kriterien sind:

\begin{itemize}
    \item \textbf{Abstände:} Abstände zwischen den Knoten verbessern die Übersichtlichkeit und die visuelle Komplexität.
    \item \textbf{Platznutzung:} Es sollte so wenig Fläche wir möglich ohne Informationsgehalt bleiben. Als gegenbeispiel kann man die Order-Knoten sehen, wie sie in der CodeCity Arbeit beschrieben wurden, bei denen die Fläche der Knoten nicht proportional zur Anzahl der Zeilen im Code ist, wodurch die Fläche an sich keinen Informationsgehalt mehr hat und außerdem viel leere Fläche entsteht.
    \item \textbf{Knoten sichtbarkeit:} Es sollte keine Knoten geben, die aufgrund von Abständen oder anderen Gründen nicht sichtbar sind. Dieses Ziel spielt speziell auf das in abschnitt \ref{sec:Treemap} beschriebene Problem ab.
    \item \textbf{Zeitaufwand:} Die Generierung des Layouts sollte in einem angemessenen Zeitrahmen erfolgen, um eine schnelle Visualisierung zu ermöglichen. Dies verbessert die Skalierbarkeit und generelle Nutzbarkeit der Visualisierung.
    \item \textbf{Seitenverhältnis:} Um die visuelle Komplexität zu reduzieren und die Verständlichkeit zu erhöhen, sollte das Seitenverhältnis der Knoten möglichst nahe bei 1:1 liegen. Dies verbessert die Lesbarkeit der Knoten und macht es einfacher, die Informationen zu erfassen.
    \item \textbf{Flächengröße:} Um die Korrelation mit dem Code zu gewährleisten, sollte die Fläche der Knoten proportional zum Metrikwert sein.
    \item \textbf{Stabilität:} Die Knoten sollten bei Änderungen die Position und Größe beibehalten, um eine stabile Visualisierung zu gewährleisten. 
\end{itemize}

In dieser Arbeit sollen space filling approaches anaylsiert werden und speziell darauf untersucht werden, wie sie sich eignenen für die definierten anforderungen. Wie gut wird was erfüllt? Wann sollte man was anwenden? Kann eine gute kombination aus verschiedenen Ansätzen gefunden werden?
Bisher wurden im Grundlagenteil vorallem die splitting algorhtmen vorgestellt, aber es gibt natürlich auch andere Ansätze, die verfolgt werden können, um Treemap Layouts zu generieren. Zum beispiel gibt es bin packing oder optimierungs algorithmen. In dieser Arbeit sollen auch diese Ansätze betrachtet werden, um zu sehen, ob sie für die Visualisierung von Codequalitätsmetriken in einer space filling layout approach geeignet sind.

Dies soll getestet werden auf basis von verschiedenen öffentlichen Repositories, die von kleinen bis großen Codebasen reichen. Als Metrik für die Fläche soll der Einfachehit halber die Anzahl der Zeilen verwendet werden.
